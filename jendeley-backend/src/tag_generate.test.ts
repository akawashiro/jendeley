import { genRight, genLeft } from "./either";
import fetch from "node-fetch";
import { logger } from "./logger";

const OLLAMA_SERVER = "http://localhost:11434/api/generate/";
const GENERATE_TAGS_PROMPT =
  "Generate tags from text. Tags must be comma separated. And each tag must be a single word. The number of tags must be at most 3. You must emit only tags.\n";

async function genTags(text: string) {
  const body = {
    model: "llama3.2",
    prompt: GENERATE_TAGS_PROMPT + "```" + text + "```",
    stream: false,
  };

  try {
    const response = await fetch(OLLAMA_SERVER, {
      method: "post",
      body: JSON.stringify(body),
      headers: { "Content-Type": "application/json" },
    });
    const data = (await response.json()) as Object;
    const response_data = data["response"];
    console.log(response_data);
    const tags = response_data.split(",");
    for (let i = 0; i < tags.length; i++) {
      tags[i] = tags[i].trim();
    }
    return genRight(tags);
  } catch (error) {
    console.log("error = " + error);
    return genLeft("Failed to generate tags");
  }
}

const SAMPLE_TEXT =
  "JiuJITsu: Removing Gadgets with Safe Register Allocation for JIT Code Generation\n\nCode-reuse attacks have the capability to craft malicious instructions from small code fragments, commonly referred to as “gadgets.” These gadgets are generated by JIT (Just-In-Time) engines as integral components of native instructions, with the flexibility to be embedded in various fields, including Displacement. In this article, we introduce a novel approach for potential gadget insertion, achieved through the manipulation of ModR/M and SIB bytes via JavaScript code. This manipulation influences a JIT engine’s register allocation and code generation algorithms. These newly generated gadgets do not rely on constants and thus evade existing constant blinding schemes. Furthermore, they can be combined with 1-byte constants, a combination that proves to be challenging to defend against using conventional constant blinding techniques. To showcase the feasibility of our approach, we provide proof-of-concept (POC) code for three distinct types of gadgets. Our research underscores the potential for attackers to exploit ModR/M and SIB bytes within JIT-generated native instructions. In response, we propose a practical defense mechanism to mitigate such attacks. We introduce JiuJITsu, a security-enhanced register allocation scheme designed to prevent harmful register assignments during the JIT code generation phase, thereby thwarting the generation of these malicious gadgets. We conduct a comprehensive analysis of JiuJITsu’s effectiveness in defending against code-reuse attacks. Our findings demonstrate that it incurs a runtime overhead of under 1% when evaluated using JetStream2 benchmarks and real-world websites.";

test("Generate tags from text", async () => {
  const title = await genTags(SAMPLE_TEXT);
  expect(title).toStrictEqual(genRight("Node.js — Run JavaScript Everywhere"));
  console.log(title);
});
